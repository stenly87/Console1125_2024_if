// безусловный оператор
goto date1809; // выполняется исключительно редко

// условные констр  укции в c#
// условный оператор if 

// синтаксис первого и обязательного блока оператора:
/*
if (условное выражение)
{ 
    тело 1
}
*/
// условное выражение - любое выражение, при вычислении 
// которого мы получим тип bool (true/false)

// тело 1 - блок кода, который выполнится, если выражение
// в условии возвращает true

// если тело состоит из одной строки, т.е. заканчивается на ;
// то можно опустить (не писать) фигурные скобки


int x1 = 10;
int x2 = 20;
int x3 = 30;
// x1 меньше x2 и при этом x2 меньше чем x3
if (x1 < x2 && x2 < x3)
{
    Console.WriteLine("Вывод строки");
    Console.WriteLine("Вывод строки 2");
}
x2 = 10;
// x1 меньше x2 и/или x2 меньше чем x3
if (x1 < x2 || x2 < x3)
{
    Console.WriteLine("Вывод строки");
    Console.WriteLine("Вывод строки 2");
}

// x1 меньше x2 и/или x2 меньше чем x3
// при данном условии вывода не произойдет, так как левая
// часть выражения = false
if (x1 < x2 & x2 < x3)
{
    Console.WriteLine("Вывод строки");
    Console.WriteLine("Вывод строки 2");
}
// ! (отрицание) инвертирует значение выражения, взятого в скобки
// теперь условие выполняется
if (!(x1 < x2 & x2 < x3))
{
    Console.WriteLine("Вывод строки");
    Console.WriteLine("Вывод строки 2");
}

// в питоне так можно, в c# нельзя
/*
if (x1 < x2 < x3)
{ 
}
*/

// второй блок оператора if (необязательный), это блок else if

/*
if (условное выражение)
{ 
    тело 1
}
else if (условное выражение 2)
{
    тело 2
}
else if (условное выражение 3)
{
    тело 3
}
else if (условное выражение N)
{
    тело N
}
*/
// блоков elseif может быть несколько, с разными условиями.
// Условия вычисляются последовательно, сверху вниз, до тех пор
// пока одно из них не вернет true в качестве результата

// третий необязательный блок это блок else

/*
if (условное выражение)
{ 
    тело 1
}
else if (условное выражение 2)
{
    тело 2
}
else
{
    код, который выполнится в случае, если ни одно выражение
    в условии не вернуло true
}
*/

string login, password;
Console.WriteLine("Логин?");
login = Console.ReadLine();
Console.WriteLine("Пароль?");
password = Console.ReadLine();

if (string.IsNullOrEmpty(login.Trim()))
{
    Console.WriteLine("Вы ввели пустой логин");
    return;
}
if (string.IsNullOrEmpty(password.Trim()))
{
    Console.WriteLine("Вы ввели пустой пароль");
    return;
}

if (login == "admin" && password == "admin")
    Console.WriteLine("Вы теперь всея админ");
else if (login == "admin" && password != "admin")
    Console.WriteLine("Вы хотели бы быть админом, но пока нет, извините. Всего вам доброго.");
else if (login == "password" && password != "password")
    Console.WriteLine("Это пароль наших тестировщиков, есть подозрение, что вы не один из них. Машина за вами уже выехала.");
else
{
    Console.WriteLine("Такого пользователя не существует. Создать? (y/n)");
    // вложенное условие
    if (Console.ReadLine() == "y")
        Console.WriteLine("Пользователь создан");
    else
        Console.WriteLine("Ну и ладно, не очень то и хотелось");
}

// второй условный оператор в C# это оператор switch
Console.WriteLine("Введите номер пары");
//int para = int.Parse(Console.ReadLine());
int.TryParse(Console.ReadLine(), out int para);
string paraLabel;
// switch в качестве выражение принимает любое выражение
// а не только логическое
switch (para)
{ // тело состоит из блоков case, каждый из которых содержит одно
    // значение и блок кода, который будет выполнен, если значение
    // выражения совпадает со значением в блоке case
    // каждый блок case заканчивается на ключевое слово break
    case 1:
        paraLabel = "Архитектура ПК";
        break;
    case 2:
        paraLabel = "ОАИП";
        break;
    // один блок кода может быть ассоциирован с несколькими
    // case-значениями
    case 3:
    // в С++ так можно, в С# нет    Console.WriteLine(3);
    case 4:
        paraLabel = "Другие пары";
        break;
    // все case-блоки содержат разные значения
    // выполняется код из того case-блока, значение которого совпадает
    // с вычисленным значением выражения из заголовка
    // если ни один case-блок не выполнен и есть блок default, то выполняется
    // он. Блок default - необязательный
    default:
        // блок по умолчанию
        paraLabel = "В это время учиться грех";
        break;
}
Console.WriteLine(paraLabel);
// вызов метода ниже
Console.WriteLine(test(para));

// третий вариант условного оператора - тернарный оператор
// по сути это сокращенный if с возвратом некоторого значения
string result;
// пример тернарного оператора
result = para > 4 ? "Пора домой" : "Пора учиться";
// строка выше делает то же самое, что и оператор if ниже
if (para > 4)
    result = "Пора домой";
else
    result = "Пора учиться";

// тернарный оператор состоит из логического выражения и двух значений или вычисляемых выражений (методов), 
// значение одного из которых будет передано в левую часть выражения
// обычно это какая-то переменная, куда мы записываем результат

// специфический синтаксис switch
// с условиями (используются шаблоны и лямбда-выражения)
string test(int para) => para switch
{
    1 => "Вы указали 1",
    2 => "Вы указали 2",
    >= 3 and < 6 => "Вы указали число больше 3 но меньше 6",
    6 or 7 or 8 => "Вы указали 6, 7 или 8",
    > 3 => "Вы указали число больше 3",
    _ => "дефолтное значение"
};


// метка для оператора goto

// циклические операторы в c#
// цикл "ДО"

int i = 0;
// до тех пор пока выполняется условие
// (если условие не выполняется цикл прекращает выполняться
// и тело может быть не выполнено ни разу)
while (i <= 10)
// выполнить тело:
{
    Console.WriteLine(++i);
    // значение переменной i необходимо изменять, поскольку иначе
    // цикл будет бесконечным

    // для досрочного прерывания цикла существует кл. слово break
    //if (i % 2 == 0)
    //    break;

    // выполнение тела цикла называется итерацией
    // итерацию можно досрочно прервать и перейти к проверке условия
    // с помощью ключевого слова continue;
    if (i % 2 == 0)
        continue;
    // из-за continue данная строка не будет выполняться для 
    // четных значений i
    Console.WriteLine("continue НЕ выполнилось");
}

// цикл "ПОСЛЕ"
// отличие от цикла ДО в том, что условие стоит после тела цикла
// соответственно оно выполняется минимум один раз независимо 
// от условия
// в конце строки после условия ставится ; поскольку оператор завершен
i = 0;
do
{
    Console.WriteLine(++i);
}
while (i <= 10);


// цикл со счетчиком
// за ключевым словом for следует конструкция из трех частей
// без указанных частей (;;) создает бесконечный цикл
for (int q = 0, j = 1; q < 100 && j > -10 ;q++, j--)
{// переменные-счетчики, созданные в цикле, ограничены его телом
    Console.WriteLine($"q = {q} j = {j}");
}

int summ = 0;
// от 0 до 100 для всех значений q
for (int q = 0; q < 100; q++)
{// выполнить суммирование
    summ += q;
}
Console.WriteLine("Сумма чисел от 0 до 99 включительно: " + summ);
summ = 0;
for (int q = 0; q < 100; q += 2)
{// выполнить суммирование
    summ += q;
}
Console.WriteLine("Сумма четных чисел от 0 до 99 включительно: " + summ);

// цикл перебора в обратном порядке
for (int q = 100; q > 0; q --)
{
    Console.WriteLine(q);    
}

// цикл с перебором
// используется для перебора всех значений в массивах и коллекциях
// при этом не требует указания индексов ячеек, перебирает многомерные массивы
// также как и одномерные
int[] ints123 = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
// foreach
// in - ключевое слово, за которым следует название коллекции или массива
foreach (int q in ints123) 
{
    // указать внутри foreach работает только для чтения
    // q = 10; // мы не можем так сделать
    Console.WriteLine(q);
}


for (; ;)
{
    
}


Console.Write("Введите кол-во чисел: ");
int.TryParse(Console.ReadLine(), out int count);

for (int q = 1; q < count; q++)
{ 
    // 1
    Console.WriteLine(q + " шт.: " + 20.4 * q);

    // 2
    Console.WriteLine("{0} шт.: {1}", q, 20.4 * q);

    // 3 *топ интерполяция строки
    Console.WriteLine($"{q} шт.: {20.4 * q}");
}
date1809:
// 5.12
double p, p0 = 1.29;
double z = 1.25 * Math.Pow(10, -4);
for (int h = 0; h <= 1000; h += 100)
{
    p = p0 * Math.Pow(Math.E, -h * z);
    Console.WriteLine($"плотность воздуха на высоте {h} = {p}");
}

// таблица умножения
for (int x = 1; x <= 9; x++)
{
    for (int y = 1; y <= 9; y++)
    {
        Console.Write($"{x*y}\t");
    }
    Console.WriteLine();
}


